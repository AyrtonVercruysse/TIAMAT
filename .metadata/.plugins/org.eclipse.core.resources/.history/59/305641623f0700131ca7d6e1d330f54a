package vub.rendering;

import java.util.Vector;

import org.mt4j.MTAndroidApplication;
import org.mt4j.components.TransformSpace;
import org.mt4j.components.visibleComponents.shapes.MTPolygon;
import org.mt4j.components.visibleComponents.shapes.MTRectangle;
import org.mt4j.components.visibleComponents.shapes.MTRectangle.PositionAnchor;
import org.mt4j.components.visibleComponents.widgets.MTTextArea;
import org.mt4j.input.inputProcessors.IGestureEventListener;
import org.mt4j.input.inputProcessors.MTGestureEvent;
import org.mt4j.input.inputProcessors.componentProcessors.tapProcessor.TapEvent;
import org.mt4j.input.inputProcessors.componentProcessors.tapProcessor.TapProcessor;
import org.mt4j.util.math.Vector3D;

import vub.ast.Definition;
import vub.ast.Node;
import vub.tiamat.StartTiamat;
import vub.menus.miniMenu;
import vub.rendering.Renderer;

public class RenderManager extends Renderer {
	private float width = 0;
	private float heigth = 0;
	private int indentionsteps;
	private float nodeWidth;
	private float nodeHeigth;
	Vector3D next = new Vector3D(0,0);
	Vector3D under = new Vector3D(0,0);
	vub.ast.Node ast;
	MTPolygon node;
	//MTPolygon parent;
	//MTRectangle drawing;

	public RenderManager(MTAndroidApplication mtApplication, vub.ast.Node ast) {
		super(mtApplication, ast);
		this.ast = ast;
		//this.parent = parent;
		//this.drawing = super.drawing;
		//drawing.setNoFill(true);
		//drawing.setAnchor(PositionAnchor.UPPER_LEFT);
		//parent.addChild(drawing);
		// TODO Auto-generated constructor stub
	}

	public  MTRectangle render(MTRectangle node, String type, Boolean indent, Boolean resetIndent) {
		if (resetIndent)
			indentionsteps = 0;
		return render(node, type, indent);
	}

	public MTRectangle render(MTRectangle node, String type, Boolean indent) {
		this.node = node;
		/*if(StartTiamat.selected == null){
			StartTiamat.general.setFillColor(white);
			
			System.out.println("RenderRender");
			
		}else StartTiamat.general.setFillColor(green);*/
		/*if(ast == StartTiamat.selected){
			System.out.println("Ja Hoor!");
			node.setFillColor(blue);
		}*/
		System.out.println("Renderer: Render");
		nodeHeigth = node.getHeightXY(TransformSpace.RELATIVE_TO_PARENT);
		nodeWidth = node.getWidthXY(TransformSpace.RELATIVE_TO_PARENT);
		drawing.addChild(node);
		if (indent)
			indentionsteps++;

		if (type == "next") {
			if (width > 700){
				indentionsteps++;
				under();
			}else{
				next();
			}
		} else if (type == "under") {
			under();
		} else {
			System.out.println("RenderManager: Wrong placementtype");
		}
		drawing.setHeightLocal(heigth+2);
		drawing.setWidthLocal(width+2);
		Vector3D newPos = node.getPosition(TransformSpace.RELATIVE_TO_PARENT);
		newPos.addLocal(new Vector3D(1,1));
		node.setPositionRelativeToParent(newPos);
		if(selected){
			drawing.setStrokeColor(red);	
			drawing.setFillColor(white);
		}
		
		//drawing.setFillColor(blue); // And the color gets added.
		//
		drawing.setNoFill(false);
		
		drawing.registerInputProcessor(new TapProcessor(mtApplication, 25,
				true, 350));
		drawing.addGestureListener(TapProcessor.class,
				new IGestureEventListener() {
					public boolean processGestureEvent(MTGestureEvent ge) {
						TapEvent te = (TapEvent) ge;
						if (te.isTapped()) {
							if (StartTiamat.selected == null) {
								System.out.println("Selected!");
								StartTiamat.selected = ast;
								selected = true;
								drawing.setStrokeColor(red);
								drawing.setFillColor(blue);
								drawing.setNoFill(false);
								// Tiamat.redraw();
								if (ast.isRoot()) {
									StartTiamat.selected = null;
									
									// selecte = false;
									// drawing.setStrokeColor(white);
								}
								// if(node.getComments().inUse() ){
								// node.getComments().show();
								// }
							} else {
								if (StartTiamat.selected == ast) {
									// selecte = false;
									// drawing.setStrokeColor(white);
									// if(StartTiamat.selected.getComments().inUse()){
									// StartTiamat.selected.getComments().hide();
									// }
									StartTiamat.selected = null;
								} else {
									// drawing.setStrokeColor(red);
									// selecte = true;
									// RenderVisitor.mapping.get(StartTiamat.selected).unselect();
									StartTiamat.selected = ast;
									drawing.setStrokeColor(red);
									if (ast.isRoot()) {
										StartTiamat.selected = null;
										// drawing.setStrokeColor(white);
									}
									// if(node.getComments().inUse() ){
									// node.getComments().show();
									// }
								}
							}
						}
						if (te.isDoubleTap()) {
							System.out.println("Dubbeltapped");

							if (menu == null) {
								menu = new miniMenu(mtApplication, "minimenu");
								StartTiamat.menuNode = ast;
								menu.show(drawing);
							} else {
								menu.hide();
								menu = null;

							}
						}
						return false;
					}
				});
	
		
		return drawing;
	}
	

	private void unindent() {
		indentionsteps = 0;
	}

	private void under() {
		Vector3D newPos = new Vector3D(indentionsteps*50, heigth);
		node.setPositionRelativeToParent(newPos);
		heigth = heigth + nodeHeigth;
		if(width < nodeWidth){
			width = nodeWidth;
		}
	}

	private void next() {
		Vector3D newPos = new Vector3D(width, 0);
		node.setPositionRelativeToParent(newPos);
		width = width+nodeWidth;
		if(nodeHeigth > heigth){
			heigth = nodeHeigth;
		}
	}

	@Override
	public MTRectangle display() {
		return drawing;
				
	}

	@Override
	public void display(
			org.mt4j.components.visibleComponents.shapes.MTRectangle parent,
			Vector3D position) {
		
	}



}
